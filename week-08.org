#+OPTIONS: toc:nil

* Review

  - What have we done so far?

** Week 1

   - curl
   - node
   - mocha/chai and tests

** Week 2

   - modules
   - npm packages
   - express
   - GET requests
   - jade
   - "views"
   - GET query parameters
   - bower
   - bootstrap
   - "static assets"
   - POST requests
   - POST bodies
   - redirects
   - Angular
   - =ng-app=
   - jade includes
   - Angular interpolation (={{ ... }}=)
   - =ng-init=
   - Angular variables/data
   - Angular data binding
   - Angular digest cycle/updates
   - =ng-click=
   - =ng-repeat=
   - bootstrap forms
   - =ng-model=
   - =ng-repeat= with =filter=
   - Angular controller
   - Angular directive and scopes
   - Angular modules

** Week 3

   - =package.json= and =main=
   - Databases
   - ORMs
   - Sequelize
   - git
   - creating models
   - database migrations
   - sqlite
   - =<model>.findAll=
   - promises
   - model column getters
   - =<model>.create=
   - =<model>.findById=
   - url in express with parameters (=:game_id=)
   - model column validations
   - model creation with a POST

** Week 4

   - sequence diagram
   - gulp
   - gulp tasks and gulp server
   - cookies
   - setting in express
   - reading in express
   - cookie vulnerability
   - =cookie-parser=
   - sessions
   - updating sessions
   - user model
   - what a user needs
   - registration page
   - login page
   - password input type
   - logout page
   - programming principles
   - mostly avoid repetition and deep cross-module knowledge
   - eslint
   - layouts with jade (via =extends=)
   - =res.locals=

** Week 5

   - Adding a column with migrations
   - gulp default task
   - HTML required input
   - =ng-model-options=
   - blur, debounce
   - =<formname>.<inputname>.$invalid=, =.$dirty=, =.$error=
   - =ng-if=
   - angular-messages
   - =ng-messages=
   - =ng-message=
   - Angular directive for input validation
   - directive =require= and =link=
   - =<ctrl>.$validators.<validationname>=
   - =ng-class=
   - =<model>.findOne=
   - =res.json=
   - model class methods
   - =<ctrl>.$asyncValidators.<validationname>=
   - =$http=, =$q=
   - dependency injection
   - content negotiation
   - =Accept: application/json= header
   - =res.format=
   - optional route parameter (=.:format?=)

** Week 6

   - jade vs angular
   - git tools
   - MVC
   - model associations
   - more migrations
   - model scopes
   - mode association methods (=setXPlayer=, =addXPlayer=, ...)

** Week 7

   - heroku
   - =package.json= scripts: =start=, =postinstall=
   - =process.env.<VARNAME>=
   - setting up redis
   - postgres and production databases
   - deep into migrations (table renaming)
   - authorization (=connect-roles=)
   - emails
   - sparkpost
   - model lifecycle hooks (=beforeCreate=, =afterCreate=)

* SPA Day

** What is it?

  SPA it short for Single Page Application

  - What does that mean to you?
  - Can you think of any examples of Single Page Applications?
  - What do you think the benefits would be? The trade-offs?

** What are we going to cover?

   - Angular routing with =ng-view= and =$route=
   - Angular module =run= and =config= 
   - Application state
   - Using 3rd party angular components
   - Building out your backend API

** What are we *not* going to cover?

   - Alternative routers (=ui-router=)
   - ??

** Implementing a single page application with Angular

   It's similar to how we are using Jade for layouts. You need to
   build a shell for the application in HTML and add a tag for where
   to render your application content. That tag is =ng-view=.

   With that tag in place, you can now use =$routeProvider= in a
   config function to setup your routes.

** Config function? What?

   Angular modules, in addition to being able to define services
   (factories, etc), controllers, directives, and filters, can also
   attach functions to two main parts of the angular lifecycle.

   - config :: when the Angular code is being loaded and prepped
   - run :: when the Angular code *has* been loaded and is starting

   These functions are just like any other injectable Angular
   functions, where Angular looks at the argument names and fills them
   in for you (with some exceptions for the =config= functions).

   What's special about config functions is that you can use them to,
   amazingly enough, configure some of the services that Angular (or
   you!) provide. Routes is one example of that.

** What are routes? Where did =$routeProvider= come from?

   Angular services, factories, values, and constants (the stuff other
   than controllers and directives) are really just syntactic sugar
   (i.e., a shorthand or easier way of writing) over a core type of
   object called a provider.

   The Angular routing service is called =$route=, and when passed to
   a config function, you ask for it with the name =$routeProvider=
   because it is the provider of the =$route= service. Providers allow
   you to access the code in a service before that service is created
   and prepped for running in your Angular application.

   Other provider examples:

   - =$logProvider= :: configure whether or not debug log messages are
        displayed to the user
   - =$httpProvider= :: configure default headers and other behavior
   - =$cookieProvider= :: default properties for newly created cookies

   As for routes, routes in Angular are *very* similar to routes in
   Express. The urls are slightly different. Instead of using "pure"
   urls, Angular attaches its route handling to the location hash. The
   hash, or fragment identifier, is a web-ish way to link to a
   particular part of a page:

     - http://some.example.site/fancyPage.html#section_A_third_paragraph

   So, in a way, Angular is using it "correctly" if a little
   oddly. Angular does use it to link to particular parts of the
   page. It just happens that those parts are in a single page
   application, and the other parts are then hidden/removed.

   #+BEGIN_SRC js
     angular.module('bewd.tictactoe', ['ngRoute'])
         .config(function($routeProvider) {
             $routeProvider.when('/a/b/c', {
                 controller: 'ABCController',
                 controllerAs: 'vm',
                 templateUrl: 'a/b/c/template.html'
             });
             $routeProvider.otherwise({
                 redirectTo: '/a/b/c'
             });
         });
   #+END_SRC

* Single Page Applications

   - Using APIs
   - Building an API
   - Managing state and routing

